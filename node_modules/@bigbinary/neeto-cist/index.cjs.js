'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ramda = require('ramda');

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// src/utils/env.ts
var NOTHING = Symbol["for"]("immer-nothing");
var DRAFTABLE = Symbol["for"]("immer-draftable");
var DRAFT_STATE = Symbol["for"]("immer-state");

// src/utils/errors.ts
var errors = process.env.NODE_ENV !== "production" ? [
// All error codes, starting by 0:
function (plugin) {
  return "The plugin for '".concat(plugin, "' has not been loaded into Immer. To enable the plugin, import and call `enable").concat(plugin, "()` when initializing your application.");
}, function (thing) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '".concat(thing, "'");
}, "This object has been frozen and should not be mutated", function (data) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
}, "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", "Immer forbids circular references", "The first or second argument to `produce` must be a function", "The third argument to `produce` must be a function or undefined", "First argument to `createDraft` must be a plain object, an array, or an immerable object", "First argument to `finishDraft` must be a draft returned by `createDraft`", function (thing) {
  return "'current' expects a draft, got: ".concat(thing);
}, "Object.defineProperty() cannot be used on an Immer draft", "Object.setPrototypeOf() cannot be used on an Immer draft", "Immer only supports deleting array indices", "Immer only supports setting array indices and the 'length' property", function (thing) {
  return "'original' expects a draft, got: ".concat(thing);
}
// Note: if more errors are added, the errorOffset in Patches.ts should be increased
// See Patches.ts for additional errors
] : [];
function die(error) {
  if (process.env.NODE_ENV !== "production") {
    var e = errors[error];
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error("[Immer] ".concat(msg));
  }
  throw new Error("[Immer] minified error nr: ".concat(error, ". Full error at: https://bit.ly/3cXEKWf"));
}

// src/utils/common.ts
var _getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _value$constructor;
  if (!value) return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || _typeof(value) !== "object") return false;
  var proto = _getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object) return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0 /* Object */) {
    Object.entries(obj).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      iter(key, value, obj);
    });
  } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
function getArchtype(thing) {
  var state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  var t = getArchtype(thing);
  if (t === 2 /* Map */) thing.set(propOrOldValue, value);else if (t === 3 /* Set */) {
    thing.add(value);
  } else thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base)) return Array.prototype.slice.call(base);
  if (!strict && isPlainObject(base)) {
    if (!_getPrototypeOf(base)) {
      var obj = /* @__PURE__ */Object.create(null);
      return Object.assign(obj, base);
    }
    return _objectSpread$1({}, base);
  }
  var descriptors = Object.getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  var keys = Reflect.ownKeys(descriptors);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var desc = descriptors[key];
    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set) descriptors[key] = {
      configurable: true,
      writable: true,
      // could live with !!desc.set as well here...
      enumerable: desc.enumerable,
      value: base[key]
    };
  }
  return Object.create(_getPrototypeOf(base), descriptors);
}
function freeze(obj) {
  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj["delete"] = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep) each(obj, function (_key, value) {
    return freeze(value, true);
  });
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}

// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
  var plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}

// src/core/scope.ts
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_: parent_,
    immer_: immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */) state.revoke_();else state.revoked_ = true;
}

// src/core/finalize.ts
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  var baseDraft = scope.drafts_[0];
  var isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_) maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value)) return value;
  var state = value[DRAFT_STATE];
  if (!state) {
    each(value, function (key, childValue) {
      return finalizeProperty(rootScope, state, value, key, childValue, path);
    });
    return value;
  }
  if (state.scope_ !== rootScope) return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    var result = state.copy_;
    var resultEach = result;
    var isSet2 = false;
    if (state.type_ === 3 /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(resultEach, function (key, childValue) {
      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet2);
    });
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (process.env.NODE_ENV !== "production" && childValue === targetObject) die(5);
  if (isDraft(childValue)) {
    var path = rootPath && parentState && parentState.type_ !== 3 /* Set */ &&
    // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    var res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

// src/core/proxy.ts
function createProxyProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type_: isArray ? 1 /* Array */ : 0 /* Object */,

    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  var target = state;
  var traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  var _Proxy$revocable = Proxy.revocable(target, traps),
    revoke = _Proxy$revocable.revoke,
    proxy = _Proxy$revocable.proxy;
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get: function get(state, prop) {
    if (prop === DRAFT_STATE) return state;
    var source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    var value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has: function has(state, prop) {
    return prop in latest(state);
  },
  ownKeys: function ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function set(state, prop, value) {
    var desc = getDescriptorFromProto(latest(state), prop);
    if (desc !== null && desc !== void 0 && desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      var current2 = peek(latest(state), prop);
      var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && (
    // special case: handle new props with value 'undefined'
    value !== void 0 || prop in state.copy_) ||
    // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty: function deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc) return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty: function defineProperty() {
    die(11);
  },
  getPrototypeOf: function getPrototypeOf(state) {
    return _getPrototypeOf(state.base_);
  },
  setPrototypeOf: function setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, function (key, fn) {
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function (state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop))) die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function (state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _desc$get;
  var desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
  // prototype, we should invoke it with the draft as context!
  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source)) return void 0;
  var proto = _getPrototypeOf(source);
  while (proto) {
    var desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc) return desc;
    proto = _getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
  }
}

// src/core/immerClass.ts
var Immer2 = /*#__PURE__*/function () {
  function Immer2(config) {
    var _this = this;
    _classCallCheck(this, Immer2);
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    this.produce = function (base, recipe, patchListener) {
      if (typeof base === "function" && typeof recipe !== "function") {
        var defaultBase = recipe;
        recipe = base;
        var self = _this;
        return function curriedProduce() {
          var _this2 = this;
          var base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          return self.produce(base2, function (draft) {
            var _recipe;
            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
          });
        };
      }
      if (typeof recipe !== "function") die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
      var result;
      if (isDraftable(base)) {
        var scope = enterScope(_this);
        var proxy = createProxy(base, void 0);
        var hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError) revokeScope(scope);else leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || _typeof(base) !== "object") {
        result = recipe(base);
        if (result === void 0) result = base;
        if (result === NOTHING) result = void 0;
        if (_this.autoFreeze_) freeze(result, true);
        if (patchListener) {
          var p = [];
          var ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else die(1, base);
    };
    this.produceWithPatches = function (base, recipe) {
      if (typeof base === "function") {
        return function (state) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }
          return _this.produceWithPatches(state, function (draft) {
            return base.apply(void 0, [draft].concat(args));
          });
        };
      }
      var patches, inversePatches;
      var result = _this.produce(base, recipe, function (p, ip) {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
    if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  _createClass(Immer2, [{
    key: "createDraft",
    value: function createDraft(base) {
      if (!isDraftable(base)) die(8);
      if (isDraft(base)) base = current(base);
      var scope = enterScope(this);
      var proxy = createProxy(base, void 0);
      proxy[DRAFT_STATE].isManual_ = true;
      leaveScope(scope);
      return proxy;
    }
  }, {
    key: "finishDraft",
    value: function finishDraft(draft, patchListener) {
      var state = draft && draft[DRAFT_STATE];
      if (!state || !state.isManual_) die(9);
      var scope = state.scope_;
      usePatchesInScope(scope, patchListener);
      return processResult(void 0, scope);
    }
    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is enabled.
     */
  }, {
    key: "setAutoFreeze",
    value: function setAutoFreeze(value) {
      this.autoFreeze_ = value;
    }
    /**
     * Pass true to enable strict shallow copy.
     *
     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
     */
  }, {
    key: "setUseStrictShallowCopy",
    value: function setUseStrictShallowCopy(value) {
      this.useStrictShallowCopy_ = value;
    }
  }, {
    key: "applyPatches",
    value: function applyPatches(base, patches) {
      var i;
      for (i = patches.length - 1; i >= 0; i--) {
        var patch = patches[i];
        if (patch.path.length === 0 && patch.op === "replace") {
          base = patch.value;
          break;
        }
      }
      if (i > -1) {
        patches = patches.slice(i + 1);
      }
      var applyPatchesImpl = getPlugin("Patches").applyPatches_;
      if (isDraft(base)) {
        return applyPatchesImpl(base, patches);
      }
      return this.produce(base, function (draft) {
        return applyPatchesImpl(draft, patches);
      });
    }
  }]);
  return Immer2;
}();
function createProxy(value, parent) {
  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  var scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

// src/core/current.ts
function current(value) {
  if (!isDraft(value)) die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value)) return value;
  var state = value[DRAFT_STATE];
  var copy;
  if (state) {
    if (!state.modified_) return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, function (key, childValue) {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}

// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
immer.produceWithPatches.bind(immer);
immer.setAutoFreeze.bind(immer);
immer.setUseStrictShallowCopy.bind(immer);
immer.applyPatches.bind(immer);
immer.createDraft.bind(immer);
immer.finishDraft.bind(immer);

/**
 * @template {Function} T
 * @param {T} func
 * @returns {T}
 */
var nullSafe = function nullSafe(func) {
  return (
    // @ts-ignore
    ramda.curryN(func.length, function () {
      var _ref;
      var dataArg = (_ref = func.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);
      return ramda.isNil(dataArg) ? dataArg : func.apply(void 0, arguments);
    })
  );
};
var noop = function noop() {};
var toLabelAndValue = function toLabelAndValue(string) {
  return {
    label: string,
    value: string
  };
};

// eslint-disable-next-line default-param-last
var getRandomInt = function getRandomInt() {
  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.MAX_SAFE_INTEGER;
  var b = arguments.length > 1 ? arguments[1] : undefined;
  if (b) {
    a = Math.ceil(a);
    b = Math.floor(b);
  } else {
    b = a;
    a = 0;
  }
  return Math.floor(Math.random() * (b - a) + a);
};
var randomPick = function randomPick() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var randomNumber = getRandomInt(0, args.length);
  return args[randomNumber];
};
var dynamicArray = function dynamicArray(count, elementGenerator) {
  return Array.from({
    length: count
  }, function (_, index) {
    return elementGenerator(index);
  });
};
var isNotEmpty = /*#__PURE__*/ramda.complement(ramda.isEmpty);
var notEquals = /*#__PURE__*/ramda.curry(function (x, y) {
  return x !== y;
});
var isNot = notEquals;
var isNotPresent = /*#__PURE__*/ramda.either(ramda.isNil, ramda.isEmpty);
var isPresent = /*#__PURE__*/ramda.complement(isNotPresent);
var notEqualsDeep = /*#__PURE__*/ramda.complement(ramda.equals);
var isNotEqualDeep = notEqualsDeep;
var modifyWithImmer = /*#__PURE__*/ramda.curry(function (modifier, data) {
  return produce(data, modifier);
});

var slugify = function slugify(string) {
  return string.toString().toLowerCase().replace(/\s+/g, "-") // Replace spaces with -
  .replace(/&/g, "-and-") // Replace & with 'and'
  .replace(/[^\w-]+/g, "") // Remove all non-word characters
  .replace(/--+/g, "-") // Replace multiple - with single -
  .replace(/^-+/, "") // Trim - from start of text
  .replace(/-+$/, "");
}; // Trim - from end of text

var humanize = function humanize(string) {
  string = string.replace(/[_-]+/g, " ").replace(/\s{2,}/g, " ").replace(/([a-z\d])([A-Z])/g, "$1" + " " + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + " " + "$2").toLowerCase().trim();
  string = string.charAt(0).toUpperCase() + string.slice(1);
  return string;
};
var snakeToCamelCase = function snakeToCamelCase(string) {
  return string.replace(/(_\w)/g, function (letter) {
    return letter[1].toUpperCase();
  });
};
var camelToSnakeCase = function camelToSnakeCase(string) {
  return string.replace(/[A-Z]/g, function (letter) {
    return "_".concat(letter.toLowerCase());
  });
};
var capitalize = function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};
var hyphenate = function hyphenate(string, fallbackString) {
  if (typeof string === "number") return String(string);
  if (string && typeof string === "string" && string.replace) {
    return string.replace(/[\s_]/g, "-").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/-+/g, "-").toLowerCase();
  }
  return fallbackString;
};
var truncate = function truncate(string, length) {
  return string.length > length ? ramda.concat(ramda.slice(0, length, string), "...") : string;
};
var _slugify = /*#__PURE__*/nullSafe(slugify);
var _humanize = /*#__PURE__*/nullSafe(humanize);
var _snakeToCamelCase = /*#__PURE__*/nullSafe(snakeToCamelCase);
var _camelToSnakeCase = /*#__PURE__*/nullSafe(camelToSnakeCase);
var _capitalize = /*#__PURE__*/nullSafe(capitalize);
// eslint-disable-next-line @bigbinary/neeto/use-camel-case-or-pascal-case-for-function-names
var _hyphenate = function _hyphenate(string, length) {
  return ramda.isNil(string) ? string : hyphenate(string, length);
};
// eslint-disable-next-line @bigbinary/neeto/use-camel-case-or-pascal-case-for-function-names
var _truncate = function _truncate(string, length) {
  return ramda.isNil(string) ? string : truncate(string, length);
};

var matchesImpl = function matchesImpl(pattern, object) {
  var __parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : object;
  if (object === pattern) return true;
  if (typeof pattern === "function" && pattern(object, __parent)) return true;
  if (ramda.isNil(pattern) || ramda.isNil(object)) return false;
  if (_typeof(pattern) !== "object") return false;
  return Object.entries(pattern).every(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    return matchesImpl(value, object[key], __parent);
  });
};
var transformObjectDeep = function transformObjectDeep(object, keyValueTransformer) {
  var objectPreProcessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  if (objectPreProcessor && typeof objectPreProcessor === "function") {
    object = objectPreProcessor(object);
  }
  if (Array.isArray(object)) {
    return object.map(function (obj) {
      return transformObjectDeep(obj, keyValueTransformer, objectPreProcessor);
    });
  } else if (object === null || _typeof(object) !== "object") {
    return object;
  }
  return Object.fromEntries(Object.entries(object).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      key = _ref4[0],
      value = _ref4[1];
    return keyValueTransformer(key, transformObjectDeep(value, keyValueTransformer, objectPreProcessor));
  }));
};
var keysToCamelCase = function keysToCamelCase(object) {
  return transformObjectDeep(object, function (key, value) {
    return [snakeToCamelCase(key), value];
  });
};
var keysToSnakeCase = function keysToSnakeCase(object) {
  return transformObjectDeep(object, function (key, value) {
    return [camelToSnakeCase(key), value];
  });
};
var serializeKeysToSnakeCase = function serializeKeysToSnakeCase(object) {
  return transformObjectDeep(object, function (key, value) {
    return [camelToSnakeCase(key), value];
  }, function (object) {
    return typeof (object === null || object === void 0 ? void 0 : object.toJSON) === "function" ? object.toJSON() : object;
  });
};
var preprocessForSerialization = function preprocessForSerialization(object) {
  return transformObjectDeep(object, function (key, value) {
    return [key, value];
  }, function (object) {
    return typeof (object === null || object === void 0 ? void 0 : object.toJSON) === "function" ? object.toJSON() : object;
  });
};
var deepFreezeObject = function deepFreezeObject(object) {
  if (object && _typeof(object) === "object" && !Object.isFrozen(object)) {
    Object.keys(object).forEach(function (property) {
      return deepFreezeObject(object[property]);
    });
    Object.freeze(object);
  }
  return object;
};
var matches = /*#__PURE__*/ramda.curry(function (pattern, object) {
  return matchesImpl(pattern, object);
});
var filterNonNull = function filterNonNull(object) {
  return Object.fromEntries(Object.entries(object).filter(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
      v = _ref6[1];
    return !ramda.isNil(v);
  }).map(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
      k = _ref8[0],
      v = _ref8[1];
    return [k, _typeof(v) === "object" && !Array.isArray(v) ? filterNonNull(v) : v];
  }));
};
var _filterNonNull = nullSafe(filterNonNull);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var removeById = /*#__PURE__*/ramda.curry(function (id, array) {
  return array.filter(function (item) {
    return item.id !== id;
  });
});
var findById = /*#__PURE__*/ramda.curry(function (id, array) {
  return array.find(function (item) {
    return item.id === id;
  });
});
var replaceById = /*#__PURE__*/ramda.curry(function (id, newItem, array) {
  return array.map(function (item) {
    return item.id === id ? newItem : item;
  });
});
var modifyById = /*#__PURE__*/ramda.curry(function (id, modifier, array) {
  return array.map(function (item) {
    return item.id === id ? modifier(item) : item;
  });
});
var findBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return array.find(matches(pattern));
});
var removeBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return array.filter(ramda.complement(matches(pattern)));
});
var replaceBy = /*#__PURE__*/ramda.curry(function (pattern, newItem, array) {
  return array.map(function (item) {
    return matches(pattern, item) ? newItem : item;
  });
});
var modifyBy = /*#__PURE__*/ramda.curry(function (pattern, modifier, array) {
  return array.map(function (item) {
    return matches(pattern, item) ? modifier(item) : item;
  });
});
var existsById = /*#__PURE__*/ramda.curry(function (id, array) {
  return array.some(function (item) {
    return item.id === id;
  });
});
var existsBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return array.some(matches(pattern));
});
var findLastBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return ramda.findLast(matches(pattern), array);
});
var findIndexById = /*#__PURE__*/ramda.curry(function (id, array) {
  return array.findIndex(function (item) {
    return item.id === id;
  });
});
var findIndexBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return array.findIndex(matches(pattern));
});
var findLastIndexBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return ramda.findLastIndex(matches(pattern), array);
});
var filterBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return array.filter(matches(pattern));
});
var countBy = /*#__PURE__*/ramda.curry(function (pattern, array) {
  return ramda.count(matches(pattern), array);
});
var copyKeys = /*#__PURE__*/ramda.curry(function (keyMap, objectArray) {
  return objectArray.map(function (object) {
    var shallowCopy = _objectSpread({}, object);
    for (var source in keyMap) {
      shallowCopy[keyMap[source]] = object[source];
    }
    return shallowCopy;
  });
});
var renameKeys = /*#__PURE__*/ramda.curry(function (keyMap, objectArray) {
  return objectArray.map(function (object) {
    var shallowCopy = _objectSpread({}, object);
    for (var source in keyMap) {
      shallowCopy[keyMap[source]] = object[source];
      delete shallowCopy[source];
    }
    return shallowCopy;
  });
});
var copyKeysDeep = /*#__PURE__*/ramda.curry(function (keyMap, objectArray) {
  var copyKeysSingleObject = function copyKeysSingleObject(object, keyMap) {
    var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : object;
    return _objectSpread(_objectSpread({}, object), ramda.fromPairs(ramda.toPairs(keyMap).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        destination = _ref2[0],
        source = _ref2[1];
      if (typeof source === "function") {
        return [destination, source(object[destination], root)];
      } else if (Array.isArray(source)) {
        return [destination, ramda.path(source, root)];
      } else if (_typeof(source) === "object") {
        return [destination, copyKeysSingleObject(object[destination], source, root)];
      }
      return [destination, object[source]];
    })));
  };
  return objectArray.map(function (object) {
    return copyKeysSingleObject(object, keyMap);
  });
});
var _removeById = /*#__PURE__*/nullSafe(removeById);
var _findById = /*#__PURE__*/nullSafe(findById);
var _replaceById = /*#__PURE__*/nullSafe(replaceById);
var _modifyById = /*#__PURE__*/nullSafe(modifyById);
var _findBy = /*#__PURE__*/nullSafe(findBy);
var _removeBy = /*#__PURE__*/nullSafe(removeBy);
var _replaceBy = /*#__PURE__*/nullSafe(replaceBy);
var _modifyBy = /*#__PURE__*/nullSafe(modifyBy);
var _existsById = /*#__PURE__*/nullSafe(existsById);
var _existsBy = /*#__PURE__*/nullSafe(existsBy);
var _findLastBy = /*#__PURE__*/nullSafe(findLastBy);
var _findIndexById = /*#__PURE__*/nullSafe(findIndexById);
var _findIndexBy = /*#__PURE__*/nullSafe(findIndexBy);
var _findLastIndexBy = /*#__PURE__*/nullSafe(findLastIndexBy);
var _filterBy = /*#__PURE__*/nullSafe(filterBy);
var _countBy = /*#__PURE__*/nullSafe(countBy);
var _copyKeys = /*#__PURE__*/nullSafe(copyKeys);
var _renameKeys = /*#__PURE__*/nullSafe(renameKeys);
var _copyKeysDeep = /*#__PURE__*/nullSafe(copyKeysDeep);

exports._camelToSnakeCase = _camelToSnakeCase;
exports._capitalize = _capitalize;
exports._copyKeys = _copyKeys;
exports._copyKeysDeep = _copyKeysDeep;
exports._countBy = _countBy;
exports._existsBy = _existsBy;
exports._existsById = _existsById;
exports._filterBy = _filterBy;
exports._filterNonNull = _filterNonNull;
exports._findBy = _findBy;
exports._findById = _findById;
exports._findIndexBy = _findIndexBy;
exports._findIndexById = _findIndexById;
exports._findLastBy = _findLastBy;
exports._findLastIndexBy = _findLastIndexBy;
exports._humanize = _humanize;
exports._hyphenate = _hyphenate;
exports._modifyBy = _modifyBy;
exports._modifyById = _modifyById;
exports._removeBy = _removeBy;
exports._removeById = _removeById;
exports._renameKeys = _renameKeys;
exports._replaceBy = _replaceBy;
exports._replaceById = _replaceById;
exports._slugify = _slugify;
exports._snakeToCamelCase = _snakeToCamelCase;
exports._truncate = _truncate;
exports.camelToSnakeCase = camelToSnakeCase;
exports.capitalize = capitalize;
exports.copyKeys = copyKeys;
exports.copyKeysDeep = copyKeysDeep;
exports.countBy = countBy;
exports.deepFreezeObject = deepFreezeObject;
exports.dynamicArray = dynamicArray;
exports.existsBy = existsBy;
exports.existsById = existsById;
exports.filterBy = filterBy;
exports.filterNonNull = filterNonNull;
exports.findBy = findBy;
exports.findById = findById;
exports.findIndexBy = findIndexBy;
exports.findIndexById = findIndexById;
exports.findLastBy = findLastBy;
exports.findLastIndexBy = findLastIndexBy;
exports.getRandomInt = getRandomInt;
exports.humanize = humanize;
exports.hyphenate = hyphenate;
exports.isNot = isNot;
exports.isNotEmpty = isNotEmpty;
exports.isNotEqualDeep = isNotEqualDeep;
exports.isNotPresent = isNotPresent;
exports.isPresent = isPresent;
exports.keysToCamelCase = keysToCamelCase;
exports.keysToSnakeCase = keysToSnakeCase;
exports.matches = matches;
exports.modifyBy = modifyBy;
exports.modifyById = modifyById;
exports.modifyWithImmer = modifyWithImmer;
exports.noop = noop;
exports.notEquals = notEquals;
exports.notEqualsDeep = notEqualsDeep;
exports.nullSafe = nullSafe;
exports.preprocessForSerialization = preprocessForSerialization;
exports.randomPick = randomPick;
exports.removeBy = removeBy;
exports.removeById = removeById;
exports.renameKeys = renameKeys;
exports.replaceBy = replaceBy;
exports.replaceById = replaceById;
exports.serializeKeysToSnakeCase = serializeKeysToSnakeCase;
exports.slugify = slugify;
exports.snakeToCamelCase = snakeToCamelCase;
exports.toLabelAndValue = toLabelAndValue;
exports.transformObjectDeep = transformObjectDeep;
exports.truncate = truncate;
//# sourceMappingURL=index.cjs.js.map
